/*
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？
例 1：
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。
示例 2：
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
示例 3：
输入：N = 21, K = 17, W = 10
输出：0.73278
0 <= K <= N <= 10000
1 <= W <= 10000
如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
此问题的判断限制时间已经减少。
*/

/*
N=21 K=17 W=10
小于17 时继续抽点数不大于21的概率

分界线是min(N, K+W-1)min(N,K+W−1)
首先，只有在分数不超过 NN 时才算获胜
可以达到的最大分数为 K+W-1 

首先我们当16点的时候存在的可能性  W=[1,10]
17,18,19,20,21,     22,23,24,25,26
1 , 1,1 ,1 ,1 ,      0,0 ,0 ,0 , 0
P(16)=1/10(1+1+1+1+1+0+0+0+0+0) = 0.5 <= N（21）的概率

当为15的时候 15抽到16的概率是 1/10
P(15) = 1/10*0.5 + p(16)

注意到每次在范围 [1, W] 内随机抽取一个整数，
且每个整数被抽取到的概率相等，因此可以得到如下状态转移方程：

dp[x]=\frac{dp[x+1]+dp[x+2]+......+dp[x+W]}{W}
述解法的时间复杂度是 O(N+KW)O(N+KW)，会超出时间限制，因此需要优化。

dp的相邻项计算差分，有如下结果：
dp[x] - dp[x+1]=\frac{dp[x+1] - dp[x+W+1]}{W}
​
​	
*/

class Solution {
    public double new21Game(int N, int K, int W) {
        if (K == 0) {
            return 1.0;
        }

        double[] dp = new double[K + W];
        for (int i = K; i <= N && i < K + W; i++) {
            dp[i] = 1.0;
        }

        for (int i = K - 1; i >= 0; i--) {
            for (int j = 1; j <= W; j++) {
                dp[i] += dp[i + j] / W;
            }
        }
        return dp[0];
    }
}
